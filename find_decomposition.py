#!/usr/bin/env python3
"""
Find and output k-set decomposition for n if α(n) ≤ k.
Outputs concrete sets in ADF (Alpha Decomposition Format).
Usage: uv run find_decomposition.py <n> <k> [output.adf]
Example: uv run find_decomposition.py 238115 4
"""

# /// script
# requires-python = ">=3.11"
# dependencies = [
#   "ortools",
# ]
# ///

import sys
import time
from itertools import combinations
from ortools.sat.python import cp_model


def popcount(x):
    """Count set bits in integer."""
    return bin(x).count('1')


def alpha_leq_k(n, k, max_slack_bits=4):
    """Find k-set decomposition using CP-SAT solver."""
    if n <= 0:
        return False, None
    
    masks = list(range(1, 2**k))
    M = min(n.bit_length() + max_slack_bits, 60)
    powers = [1 << t for t in range(M + 1)]
    
    model = cp_model.CpModel()
    
    d = {mask: model.NewIntVar(0, M, f"d_{mask}") for mask in masks}
    y = {mask: model.NewIntVar(1, powers[-1], f"y_{mask}") for mask in masks}
    
    for mask in masks:
        model.AddElement(d[mask], powers, y[mask])
    
    for mask1 in masks:
        for mask2 in masks:
            if mask1 != mask2 and (mask1 & mask2) == mask2:
                model.Add(d[mask1] <= d[mask2])
    
    # Region constraints via Möbius inversion - ensure non-negative region sizes
    for K in masks:
        terms = []
        for J in masks:
            if (J & K) == K:
                sign = 1 if (popcount(J) - popcount(K)) % 2 == 0 else -1
                terms.append(sign * d[J])
        model.Add(sum(terms) >= 0)  # Region sizes must be non-negative
    
    singletons = [1 << i for i in range(k)]
    for i in range(len(singletons) - 1):
        if singletons[i] in d and singletons[i+1] in d:
            model.Add(d[singletons[i]] >= d[singletons[i+1]])
    
    ie_sum = sum((1 if popcount(mask) % 2 == 1 else -1) * y[mask] for mask in masks)
    model.Add(ie_sum == n)
    
    solver = cp_model.CpSolver()
    solver.parameters.num_search_workers = 1
    
    status = solver.Solve(model)
    
    if status in (cp_model.OPTIMAL, cp_model.FEASIBLE):
        d_vals = {mask: solver.Value(d[mask]) for mask in masks}
        return True, d_vals
    else:
        return False, None


def construct_sets(d_vals, k):
    """Construct concrete sets from intersection sizes."""
    # Calculate exclusive region sizes using Möbius inversion
    regions = {}
    masks = list(range(1, 2**k))
    
    for K in masks:
        region_size = 0
        for J in masks:
            if (J & K) == K:
                bits_diff = bin(J).count('1') - bin(K).count('1')
                sign = 1 if bits_diff % 2 == 0 else -1
                region_size += sign * d_vals[J]
        regions[K] = region_size
    
    # Build sets by assigning elements to regions
    sets = [set() for _ in range(k)]
    element_counter = 0
    
    for mask in masks:
        if regions[mask] > 0:
            # Add elements to this region
            new_elements = set(range(element_counter, element_counter + regions[mask]))
            element_counter += regions[mask]
            
            # Add to appropriate sets based on mask
            for i in range(k):
                if mask & (1 << i):
                    sets[i].update(new_elements)
    
    return sets


def verify_decomposition(sets, n):
    """Verify that the k sets produce the correct union size using inclusion-exclusion."""
    k = len(sets)
    if k == 0:
        return n == 0
    
    # Compute all intersection sizes
    masks = list(range(1, 2**k))
    intersection_sizes = {}
    
    for mask in masks:
        # Find intersection of sets indicated by mask
        intersection = None
        for i in range(k):
            if mask & (1 << i):
                if intersection is None:
                    intersection = sets[i].copy()
                else:
                    intersection = intersection & sets[i]
        intersection_sizes[mask] = len(intersection) if intersection else 0
    
    # Apply inclusion-exclusion principle
    result = 0
    for mask in masks:
        bits = bin(mask).count('1')
        sign = 1 if bits % 2 == 1 else -1
        result += sign * (1 << intersection_sizes[mask])
    
    return result == n


def write_adf_file(sets, n, k, filename):
    """Write sets to ADF (Alpha Decomposition Format) file."""
    with open(filename, 'w') as f:
        # Write comment header
        f.write(f"c Alpha decomposition for n={n} with k={k} sets\n")
        f.write(f"c Generated by find_decomposition.py\n")
        f.write(f"c Verified: |2^S1 ∪ ... ∪ 2^S{k}| = {n}\n")
        
        # Write problem line
        f.write(f"p alpha {n} {k}\n")
        
        # Write set lines
        for i, s in enumerate(sets, 1):
            elements = ' '.join(map(str, sorted(s)))
            if elements:
                f.write(f"s {i} {elements} 0\n")
            else:
                f.write(f"s {i} 0\n")
    
    print(f"\nADF file written to: {filename}")


def main():
    if len(sys.argv) < 3:
        print(__doc__)
        sys.exit(1)
    
    n = int(sys.argv[1])
    k = int(sys.argv[2])
    output_file = sys.argv[3] if len(sys.argv) > 3 else f"n_{n}_k{k}.adf"
    
    print(f"Finding {k}-set decomposition for n = {n}")
    print(f"Binary: {bin(n)[2:]}\n")
    
    start = time.perf_counter()
    feasible, d_vals = alpha_leq_k(n, k)
    elapsed = time.perf_counter() - start
    
    if not feasible:
        print(f"✗ No {k}-set decomposition exists (α({n}) > {k})")
        print(f"Proved in {elapsed*1000:.1f}ms")
        sys.exit(1)
    
    print(f"✓ Found {k}-set decomposition in {elapsed*1000:.1f}ms\n")
    
    # Print intersection sizes
    print("Intersection sizes:")
    for i in range(k):
        mask = 1 << i
        print(f"  |S_{i+1}| = {d_vals[mask]}")
    
    # Construct concrete sets
    sets = construct_sets(d_vals, k)
    
    print("\nConcrete sets:")
    for i, s in enumerate(sets, 1):
        print(f"  S{i} = {sorted(s)}")
    
    # Verify
    if verify_decomposition(sets, n):
        print(f"\n✓ Verification successful: |⋃ 2^Si| = {n}")
    else:
        print("\n✗ Verification failed!")
        sys.exit(1)
    
    # Write ADF file
    write_adf_file(sets, n, k, output_file)


if __name__ == "__main__":
    main()